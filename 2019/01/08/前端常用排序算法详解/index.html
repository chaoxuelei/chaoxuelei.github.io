<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Joshua"><title>前端常用排序详解 · Joshua-blog_晁学磊</title><meta name="description" content="排序JS本身数组的sort方法，可以满足日常业务操作中很多的场景了。但很多时候我们还需要知道选择排序 冒泡排序 和快速排序 的方式。
冒泡排序文字例子：
123456E A D B H //原始序列A E D B H //经过一次计算（A、E交换）A D E B H //再次计算（D、E交换）A D"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="main"><div class="page-top animated fadeInDown"><div class="main"><div class="sidebar animated fadeInDown"><div class="logo-title"><a href="/"><img src="/images/logo@2x.png" style="height:40px;"></a></div></div><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="cont-right"><div class="post-title"><h3><h2 style="text-align: center;">前端常用排序详解</h2></h3></div><div class="post-content"><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>JS本身数组的sort方法，可以满足日常业务操作中很多的场景了。<br>但很多时候我们还需要知道选择排序 冒泡排序 和快速排序 的方式。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>文字例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E A D B H //原始序列</span><br><span class="line">A E D B H //经过一次计算（A、E交换）</span><br><span class="line">A D E B H //再次计算（D、E交换）</span><br><span class="line">A D B E H //再次计算（B、E交换）</span><br><span class="line">//将上面所有的循环再循环 arr.length-2次</span><br><span class="line">A B D E H //最终结果</span><br></pre></td></tr></table></figure>

<p>动图：<br><img src="https://i.loli.net/2018/08/15/5b73ef15c9a2f.gif" alt></p>
<p>代码实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="comment">//比较多少个循环，内部循环一次少一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> outer = len ; outer &gt;= <span class="number">2</span>; outer--) &#123;</span><br><span class="line">        <span class="comment">//前后比较，从第1个开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> inner = <span class="number">0</span>; inner &lt;=outer - <span class="number">1</span>; inner++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[inner] &gt; arr[inner + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[inner];</span><br><span class="line">                arr[inner] = arr[inner + <span class="number">1</span>];</span><br><span class="line">                arr[inner + <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="comment">//[arr2[0],arr2[1]] = [arr2[1],arr2[0]]  //这一步可用ES6解构赋值实现位置交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是从数组的开头开始，将第一个元素和其他元素作比较，检查完所有的元素后，最小的放在第一个位置，接下来再开始从第二个元素开始，重复以上一直到最后。</p>
<p>动图：<br><img src="https://i.loli.net/2018/08/15/5b73f1fa46b4e.gif" alt></p>
<p>外层循环从0开始到length-1， 然后内层比较，最小的放开头，代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//从第i个开始，比较第i个和第j个的大小，小于第i个就交换，知道不小于，再累加i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i ; j&lt;len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                [arr[i],arr[j]] = [arr[j],arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，继续接，可能是中间数，就插在中间….依次。</p>
<p>动图：<br><img src="https://i.loli.net/2018/08/15/5b73f3b0afb4b.gif" alt></p>
<p>原理：</p>
<p>首先将待排序的第一个记录作为一个有序段。<br>从第二个开始，到最后一个，依次和前面的有序段进行比较，确定插入位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;  <span class="comment">//外循环从1开始，默认arr[0]是有序段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;  <span class="comment">//j = i,将arr[j]依次插入有序段中进行比较，第j个大于第i个就终端换下一个</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                [arr[j],arr[j<span class="number">-1</span>]] = [arr[j<span class="number">-1</span>],arr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实和冒泡排序很相似，只是将换位置放到了最后一步。</p>
<p>乍一看，好像插入排序速度还不慢，但是要知道： 当序列正好逆序的时候，每次插入都要一次次交换，这个速度和冒泡排序是一样的，时间复杂度O(n²)； 当然运气好，前面是有序的，那时间复杂度就只有O(n)了，直接插入即可。</p>
<p>|排序算法|平均时间复杂度|最坏时间复杂度|空间复杂度|否稳定|<br>|–|–|–|–|–|–|–|<br>|冒泡排序|O(n²)|O(n²)|O(1)|是|<br>|选择排序|O(n²)|O(n²)|O(1)|不是|<br>|插入排序|O(n²)|O(n²)|O(1)|是<br>还有一些更高级的排序算法，但是稳定性并不高，这里就不在写了。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归，其实就是自己调用自己。</p>
<p>递归步骤：</p>
<blockquote>
<p>寻找出口，递归一定有一个出口，锁定出口，保证不会死循环<br>递归条件，符合递归条件，自己调用自己。</p>
</blockquote>
<p>例子：<br>实现对一个对象(object)的深度克隆：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所谓深度克隆，就是当对象的某个属性值为object或array的时候，要获得一份copy，而不是直接拿到引用值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">origin,target</span>) </span>&#123;  <span class="comment">//origin是被克隆对象，target是我们获得copy</span></span><br><span class="line">    <span class="keyword">var</span> target = target || &#123;&#125;; <span class="comment">//定义target</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> origin) &#123;  <span class="comment">//遍历原对象</span></span><br><span class="line">        <span class="keyword">if</span>(origin.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(origin[key])) &#123; <span class="comment">//如果是数组</span></span><br><span class="line">                target[key] = [];</span><br><span class="line">                deepClone(origin[key],target[key]) <span class="comment">//递归</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> origin[key] === <span class="string">'object'</span> &amp;&amp; origin[key] !== <span class="literal">null</span>) &#123;</span><br><span class="line">                target[key] = &#123;&#125;;</span><br><span class="line">                deepClone(origin[key],target[key]) <span class="comment">//递归</span></span><br><span class="line">            &#125;</span><br><span class="line">            target[key] = origin[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码不够简洁，改造一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sourceCopy = source <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> source) &#123;</span><br><span class="line">    sourceCopy[item] = <span class="keyword">typeof</span> source[item] === <span class="string">'object'</span> ? deepClone(source[item]) : source[item];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sourceCopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：实现一个Array flat()方法，将嵌套数组扁平化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat(); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">this</span>.forEach(<span class="function">(<span class="params">item,idx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">            arr = arr.concat(item.flat()); <span class="comment">//递归去处理数组元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push(item)   <span class="comment">//非数组直接push进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr;   <span class="comment">//递归出口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文中的图片来源：<a href="https://visualgo.net/zh" target="_blank" rel="noopener">https://visualgo.net/zh</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-01-08</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a></div></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://chaoxuelei.github.io/2019/01/08/前端常用排序算法详解/,Joshua-blog_晁学磊,前端常用排序详解,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/02/08/数据可视化畅想/" title="数据可视化畅想">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/09/08/非常好的网站和技巧合集【持续更新】/" title="非常好的网站和技巧合集【持续更新】">下一篇</a></li></ul></div></div></div></div><div class="footer"><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>